[
    {
        "id": "e5eeaf82157125e5",
        "type": "function",
        "z": "5b8625b7fcd2c6db",
        "name": "Process Gateway Stats",
        "func": "// Process data from MongoDB collector\nconst now = Date.now();\n\n// Initialize or get stats from flow context\nlet gatewayList = flow.get('gatewayList') || [];\nlet gatewayStats = flow.get('gatewayStats') || {};\nlet sensorTypeSummary = flow.get('sensorTypeSummary') || {};\nlet dateList = flow.get('dateList') || [];\nlet dateBasedStats = flow.get('dateBasedStats') || {};\n\n// Process topic to extract date information\nlet collectionDate = 'current';\nif (msg.topic && msg.topic.includes('/')) {\n    // Extract date from topic if available (format: projects/em-beta/subscriptions/gateway-stats/YYYY-MM-DD)\n    const topicParts = msg.topic.split('/');\n    if (topicParts.length > 3) {\n        const possibleDate = topicParts[topicParts.length - 1];\n        // Simple validation for date format (YYYY-MM-DD)\n        if (/^\\d{4}-\\d{2}-\\d{2}$/.test(possibleDate)) {\n            collectionDate = possibleDate;\n\n            // Add to date list if not already there\n            if (!dateList.includes(collectionDate)) {\n                dateList.push(collectionDate);\n                // Sort dates in descending order (newest first)\n                dateList.sort((a, b) => {\n                    if (a === 'current') return -1;\n                    if (b === 'current') return 1;\n                    return Number(new Date(b)) - Number(new Date(a));\n                });\n                flow.set('dateList', dateList);\n            }\n        }\n    }\n}\n\n// Process incoming payload\nif (msg.payload && typeof msg.payload === 'object') {\n    try {\n        // Get the timestamp for this update\n        const updateTimestamp = now;\n\n        // Initialize date stats if new\n        if (!dateBasedStats[collectionDate]) {\n            dateBasedStats[collectionDate] = {\n                gatewayList: [],\n                gatewayStats: {},\n                sensorTypeSummary: {},\n                lastUpdate: updateTimestamp\n            };\n        }\n\n        // Reference to current date's stats\n        let currentDateStats = dateBasedStats[collectionDate];\n\n        // Check if we have a direct gateway message or a collection of gateways\n        if (msg.payload.gateway) {\n            // Process a single gateway\n            const gateway = msg.payload.gateway;\n\n            // Store or update in the gateway list for this date\n            if (!currentDateStats.gatewayList.includes(gateway)) {\n                currentDateStats.gatewayList.push(gateway);\n            }\n\n            // Store or update in the global gateway list\n            if (!gatewayList.includes(gateway)) {\n                gatewayList.push(gateway);\n                flow.set('gatewayList', gatewayList);\n            }\n\n            // Update gateway stats for this date\n            currentDateStats.gatewayStats[gateway] = {\n                ...msg.payload,\n                lastUpdate: updateTimestamp,\n                collectionDate: collectionDate\n            };\n\n            // If this is the current date, also update the main gateway stats\n            if (collectionDate === 'current') {\n                gatewayStats[gateway] = {\n                    ...msg.payload,\n                    lastUpdate: updateTimestamp,\n                    collectionDate: collectionDate\n                };\n            }\n        } else {\n            // Process multiple gateways\n            Object.keys(msg.payload).forEach(key => {\n                // Skip the special entries\n                if (key === 'sensorTypes' || key === 'meta') {\n                    return;\n                }\n\n                const gateway = key;\n                const stats = msg.payload[key];\n\n                // Add to date-specific gateway list if new\n                if (!currentDateStats.gatewayList.includes(gateway)) {\n                    currentDateStats.gatewayList.push(gateway);\n                }\n\n                // Add to global gateway list if new\n                if (!gatewayList.includes(gateway)) {\n                    gatewayList.push(gateway);\n                }\n\n                // Update gateway stats for this date\n                currentDateStats.gatewayStats[gateway] = {\n                    ...stats,\n                    lastUpdate: stats.lastUpdate || updateTimestamp,\n                    collectionDate: collectionDate\n                };\n\n                // If this is the current date, also update the main gateway stats\n                if (collectionDate === 'current') {\n                    gatewayStats[gateway] = {\n                        ...stats,\n                        lastUpdate: stats.lastUpdate || updateTimestamp,\n                        collectionDate: collectionDate\n                    };\n                }\n            });\n\n            // Store updated gateway lists\n            flow.set('gatewayList', gatewayList);\n\n            // Process global sensor types if available\n            if (msg.payload.sensorTypes) {\n                currentDateStats.sensorTypeSummary = msg.payload.sensorTypes;\n\n                // If this is the current date, update the main sensor type summary\n                if (collectionDate === 'current') {\n                    sensorTypeSummary = msg.payload.sensorTypes;\n                    flow.set('sensorTypeSummary', sensorTypeSummary);\n                }\n            }\n        }\n\n        // Store updated date-based stats\n        flow.set('dateBasedStats', dateBasedStats);\n\n        // If we're processing current data, update the main gateway stats\n        if (collectionDate === 'current') {\n            flow.set('gatewayStats', gatewayStats);\n        }\n\n        // Create aggregate stats for all gateways for this date\n        const dateGatewayStats = currentDateStats.gatewayStats;\n        const totalElements = Object.values(dateGatewayStats).reduce((sum, gateway) => sum + (gateway.elements || 0), 0);\n        const totalRecentReadings = Object.values(dateGatewayStats).reduce((sum, gateway) => sum + (gateway.recentReadings || 0), 0);\n        const totalDataPoints = Object.values(dateGatewayStats).reduce((sum, gateway) => sum + (gateway.dataPoints || 0), 0);\n\n        // Get unique sensor types across all gateways for this date\n        const sensorTypes = {};\n        Object.values(dateGatewayStats).forEach(gateway => {\n            if (gateway.sensorTypes) {\n                Object.entries(gateway.sensorTypes).forEach(([type, count]) => {\n                    if (!sensorTypes[type]) {\n                        sensorTypes[type] = 0;\n                    }\n                    sensorTypes[type] += count;\n                });\n            }\n        });\n\n        // Build summary data for UI\n        const summary = {\n            gateways: currentDateStats.gatewayList.length,\n            totalElements: totalElements,\n            totalReadings: totalRecentReadings,\n            totalDataPoints: totalDataPoints,\n            sensorTypeCount: Object.keys(sensorTypes).length,\n            lastUpdate: updateTimestamp,\n            collectionDate: collectionDate\n        };\n\n        // Build the complete UI payload\n        const uiPayload = {\n            summary: summary,\n            gateways: dateGatewayStats,\n            sensorTypes: currentDateStats.sensorTypeSummary || sensorTypes,\n            gatewayList: currentDateStats.gatewayList,\n            dateList: dateList,\n            selectedDate: collectionDate,\n            dateBasedStats: dateBasedStats,\n            allGateways: gatewayList\n        };\n\n        return { payload: uiPayload };\n    } catch (e) {\n        node.error(`Error processing gateway stats: ${e.message}`);\n        node.error(e.stack);\n\n        return {\n            payload: {\n                summary: {\n                    gateways: gatewayList.length,\n                    lastUpdate: now,\n                    error: e.message,\n                    collectionDate: collectionDate\n                },\n                gateways: gatewayStats,\n                sensorTypes: sensorTypeSummary,\n                gatewayList: gatewayList,\n                dateList: dateList,\n                selectedDate: collectionDate\n            }\n        };\n    }\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "// Initialize data structures\nflow.set('gatewayList', []);\nflow.set('gatewayStats', {});\nflow.set('sensorTypeSummary', {});\nflow.set('dateList', ['current']);\nflow.set('dateBasedStats', {\n    current: {\n        gatewayList: [],\n        gatewayStats: {},\n        sensorTypeSummary: {},\n        lastUpdate: Date.now()\n    }\n});\n",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 260,
        "wires": [
            [
                "2df224c04f4084a9"
            ]
        ]
    }
]

<!-- Generated by SpecStory -->

# Enhancing the MCP Todo List Server (2025-02-23 14:35:46)

_**User**_

WHat else can I add to this mcp_todo_list server?

---

_**Assistant**_

Here are a few ideas for additional features you could add to your FastMCP Todo Server:

```python:src/fastmcp_todo_server/__init__.py
class TodoServer:
    def register_tools(self):
        # ... existing code ...

        @self.server.tool("update_todo")
        async def update_todo(todo_id: str, updates: dict, ctx: Context = None) -> str:
            """Update an existing todo by ID"""
            logger.debug(f"update_todo called with todo_id={todo_id}, updates={updates}")
            try:
                result = self.collection.update_one({"id": todo_id}, {"$set": updates})
                if result.modified_count == 0:
                    return json.dumps({"status": "error", "message": "Todo not found"})
                
                if ctx is not None:
                    try:
                        ctx.info(f"Updated todo {todo_id}")
                    except ValueError:
                        logger.debug("Context not available for logging")
                
                return json.dumps({"status": "success"})
            except Exception as e:
                logger.error(f"Error updating todo: {str(e)}", exc_info=True)
                return json.dumps({"status": "error", "message": str(e)})

        @self.server.tool("delete_todo")  
        async def delete_todo(todo_id: str, ctx: Context = None) -> str:
            """Delete a todo by ID"""
            logger.debug(f"delete_todo called with todo_id={todo_id}")
            try:
                result = self.collection.delete_one({"id": todo_id})
                if result.deleted_count == 0:
                    return json.dumps({"status": "error", "message": "Todo not found"})
                
                if ctx is not None:
                    try:
                        ctx.info(f"Deleted todo {todo_id}")
                    except ValueError:
                        logger.debug("Context not available for logging")

                return json.dumps({"status": "success"})
            except Exception as e:
                logger.error(f"Error deleting todo: {str(e)}", exc_info=True)
                return json.dumps({"status": "error", "message": str(e)})
        
        # ... existing code ...
```

Explanation of changes:
- Added an `update_todo` tool to allow updating existing todos by ID. It takes the todo ID and a dict of fields to update. 
- Added a `delete_todo` tool to allow deleting todos by ID.
- Both new tools log the action with the context if available, similar to the existing `add_todo` tool.

Some other ideas to consider:
- Pagination support for `query_todos`
- Ability to mark todos as completed 
- Due dates for todos
- Assigning todos to specific users
- Recurring todos
- Search functionality 
- Tagging/categorization of todos
- Integration with other systems (e.g. sending email/Slack notifications)

Let me know if you would like me to elaborate on any of these ideas or help with the implementation!

---

_**User**_

Lets add a tool that lets the agent post to the mqtt server directly 

---

_**Assistant**_

Sure, let's add a tool that allows the agent to publish messages directly to the MQTT server. Here's how you can implement it:

```python:src/fastmcp_todo_server/__init__.py
import paho.mqtt.client as mqtt

class TodoServer:
    def __init__(self):
        # ... existing code ...
        
        # MQTT client configuration
        self.mqtt_client = mqtt.Client()
        self.mqtt_client.connect(MQTT_HOST, MQTT_PORT, MQTT_KEEPALIVE)
        
        # ... existing code ...

    def register_tools(self):
        # ... existing code ...

        @self.server.tool("mqtt_publish")
        async def mqtt_publish(topic: str, message: str, ctx: Context = None) -> str:
            """Publish a message to the specified MQTT topic"""
            logger.debug(f"mqtt_publish called with topic={topic}, message={message}")
            try:
                result = self.mqtt_client.publish(topic, message)
                result.wait_for_publish()
                
                if result.is_published():
                    if ctx is not None:
                        try:
                            ctx.info(f"Published message to topic {topic}")
                        except ValueError:
                            logger.debug("Context not available for logging")
                    
                    return json.dumps({"status": "success"})
                else:
                    return json.dumps({"status": "error", "message": "Message not published"})
            except Exception as e:
                logger.error(f"Error publishing MQTT message: {str(e)}", exc_info=True)
                return json.dumps({"status": "error", "message": str(e)})

        # ... existing code ...
```

Explanation of changes:
- Imported the `paho.mqtt.client` module to use for MQTT functionality.
- In the `TodoServer` constructor, created an MQTT client instance and connected it to the broker using the configured host, port, and keepalive settings.
- Added an `mqtt_publish` tool that takes a topic and message as parameters. 
- Inside the tool, it publishes the message to the specified topic using the MQTT client.
- It waits for the publish to complete, then checks if it was successful.
- If successful, it logs the action with the context if available and returns a success status.
- If unsuccessful or an exception occurs, it returns an error status with the details.

Now the agent can use the `mqtt_publish` tool to send messages directly to any topic on the MQTT server. For example:

```
mqtt_publish topic="some/topic" message="Hello from the agent!"
```

This allows for flexible integration with other systems that may be listening on those MQTT topics. Let me know if you have any other questions!

---



---

